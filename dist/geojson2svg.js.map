{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "/Users/willmcclellan/git/willmcclellan/geojson2svg/node_modules/deepmerge/index.js",
    "/Users/willmcclellan/git/willmcclellan/geojson2svg/node_modules/multigeojson/index.js",
    "/Users/willmcclellan/git/willmcclellan/geojson2svg/src/converter.js",
    "/Users/willmcclellan/git/willmcclellan/geojson2svg/src/instance.js",
    "/Users/willmcclellan/git/willmcclellan/geojson2svg/src/main.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.deepmerge = factory();\n    }\n}(this, function () {\n\nfunction isMergeableObject(val) {\n    var nonNullObject = val && typeof val === 'object'\n\n    return nonNullObject\n        && Object.prototype.toString.call(val) !== '[object RegExp]'\n        && Object.prototype.toString.call(val) !== '[object Date]'\n}\n\nfunction emptyTarget(val) {\n    return Array.isArray(val) ? [] : {}\n}\n\nfunction cloneIfNecessary(value, optionsArgument) {\n    var clone = optionsArgument && optionsArgument.clone === true\n    return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value\n}\n\nfunction defaultArrayMerge(target, source, optionsArgument) {\n    var destination = target.slice()\n    source.forEach(function(e, i) {\n        if (typeof destination[i] === 'undefined') {\n            destination[i] = cloneIfNecessary(e, optionsArgument)\n        } else if (isMergeableObject(e)) {\n            destination[i] = deepmerge(target[i], e, optionsArgument)\n        } else if (target.indexOf(e) === -1) {\n            destination.push(cloneIfNecessary(e, optionsArgument))\n        }\n    })\n    return destination\n}\n\nfunction mergeObject(target, source, optionsArgument) {\n    var destination = {}\n    if (isMergeableObject(target)) {\n        Object.keys(target).forEach(function (key) {\n            destination[key] = cloneIfNecessary(target[key], optionsArgument)\n        })\n    }\n    Object.keys(source).forEach(function (key) {\n        if (!isMergeableObject(source[key]) || !target[key]) {\n            destination[key] = cloneIfNecessary(source[key], optionsArgument)\n        } else {\n            destination[key] = deepmerge(target[key], source[key], optionsArgument)\n        }\n    })\n    return destination\n}\n\nfunction deepmerge(target, source, optionsArgument) {\n    var array = Array.isArray(source);\n    var options = optionsArgument || { arrayMerge: defaultArrayMerge }\n    var arrayMerge = options.arrayMerge || defaultArrayMerge\n\n    if (array) {\n        return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument)\n    } else {\n        return mergeObject(target, source, optionsArgument)\n    }\n}\n\ndeepmerge.all = function deepmergeAll(array, optionsArgument) {\n    if (!Array.isArray(array) || array.length < 2) {\n        throw new Error('first argument should be an array with at least two elements')\n    }\n\n    // we are sure there are at least 2 values, so it is safe to have no initial value\n    return array.reduce(function(prev, next) {\n        return deepmerge(prev, next, optionsArgument)\n    })\n}\n\nreturn deepmerge\n\n}));\n",
    "//index.js \n(function() { \n\tvar singles = ['Point', 'LineString', 'Polygon'];\n\tvar multies = ['MultiPoint', 'MultiLineString', 'MultiPolygon'];\n\tfunction explode(g) {\n\t  if( multies.indexOf(g.type) > -1) {\n\t    return g.coordinates.map(function(part) {\n\t      var single = {};\n\t      single.type = g.type.replace('Multi','');\n\t      single.coordinates = part;\n        if(g.crs) single.crs = g.crs;\n\t      return single;\n\t    });  \n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tfunction implode(gs) {\n\t  var sameType = gs.every(function(g) { \n\t    return singles.indexOf(g.type) > -1;\n\t  })\n    var crs = gs[0].crs || 0;\n    var sameCrs = gs.every(function(g) {\n      var gcrs = g.crs || 0;\n      return gcrs == crs;\n    });\n\t  if(sameType && sameCrs) {\n\t    var multi = {};\n\t    multi.type = 'Multi' + gs[0].type;\n\t    multi.coordinates = [];\n      if(crs != 0) multi.crs = crs;\n\t    gs.forEach(function(g) {\n\t      multi.coordinates.push(g.coordinates);\n\t    });\n\t    return multi;\n\t  } else {\n\t    return false;\n\t  }\n\t};\n\tvar multigeojson = {\n\t  explode: explode,\n\t  implode: implode\n\t};\n\tif(typeof module !== 'undefined' && module.exports) {\n\t  module.exports = multigeojson;\n\t} else if(window) {\n\t  window.multigeojson = multigeojson;\n\t}\n})();\n",
    "//converter.js\nvar multi = require('multigeojson');\nfunction getCoordString(coords,res,origin) {\n  //origin - svg image origin \n  var coordStr = coords.map(function(coord) {\n    return (coord[0] - origin.x)/res + ',' + (origin.y - coord[1])/res;\n  });\n  return coordStr.join(' ');\n}\nfunction addAttributes(ele,attributes) {\n  var part = ele.split('/>')[0];\n  for(var key in attributes) {\n    if(attributes[key]) {\n      part += ' ' + key + '=\"' + attributes[key] + '\"';\n    }\n  }\n  return part + ' />';\n}\n\nfunction point(geom,res,origin,opt) {\n  var r = opt && opt.r ? opt.r : 1;\n  var pointAsCircle = opt && opt.hasOwnProperty('pointAsCircle') \n    ? opt.pointAsCircle : false;\n  var coords = getCoordString([geom.coordinates],res,origin);\n  if (pointAsCircle) {\n    return [coords];\n  } else {\n    return [\n      'M' + coords \n      + ' m'+ -r+ ',0'+ ' a'+r+','+ r + ' 0 1,1 '+ 2*r + ','+0\n      + ' a'+r+','+ r + ' 0 1,1 '+ -2*r + ','+0\n    ];\n  }\n}\nfunction multiPoint(geom,res,origin,opt) {\n  var explode = opt && opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function(single) {\n    return point(single,res,origin,opt)[0];\n  });\n  if(!explode) return [paths.join(' ')];\n  return paths;\n\n}\nfunction lineString(geom,res,origin,otp) {\n  var coords = getCoordString(geom.coordinates,res,origin);\n  var path = 'M'+ coords;  \n  return [path];\n}\nfunction multiLineString(geom,res,origin,opt) {\n  var explode = opt && opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function(single) {\n    return lineString(single,res,origin,opt)[0];\n  });\n  if(!explode) return [paths.join(' ')];\n  return paths;\n}\nfunction polygon(geom,res,origin,opt) {\n  var mainStr,holes,holeStr;\n  mainStr = getCoordString(geom.coordinates[0],res,origin);\n  if (geom.coordinates.length > 1) {\n    holes = geom.coordinates.slice(1,geom.coordinates.length);\n  }\n  var path = 'M'+ mainStr;\n  if(holes) {\n    for(var i=0;i<holes.length; i++) {\n      path += ' M' +  getCoordString(holes[i],res,origin);\n    }\n  }\n  path += 'Z';\n  return [path];\n}\nfunction multiPolygon(geom,res,origin,opt) {\n  var explode = opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function(single) {\n    return polygon(single,res,origin,opt)[0];\n  });\n  if(!explode) return [paths.join(' ').replace(/Z/g,'') + 'Z'];\n  return paths;\n}\nmodule.exports = {\n  Point: point,\n  MultiPoint: multiPoint,\n  LineString: lineString,\n  MultiLineString: multiLineString,\n  Polygon: polygon,\n  MultiPolygon: multiPolygon\n};\n",
    "var merge = require('deepmerge'),\n\tconverter = require('./converter.js');\n\n//g2svg as geojson2svg (shorthand)\nvar g2svg = function(options) {\n  this.options = options || {};\n  this.viewportSize = this.options.viewportSize || \n    {width: 256, height: 256};\n  this.mapExtent = this.options.mapExtent ||\n    {\n      left: -20037508.342789244,\n      right: 20037508.342789244,\n      bottom: -20037508.342789244,\n      top: 20037508.342789244\n    };\n  this.res = this.calResolution(this.mapExtent,this.viewportSize,\n    this.options.fitTo);\n};\ng2svg.prototype.calResolution = function(extent,size,fitTo) {\n  var xres = (extent.right - extent.left)/size.width;\n  var yres = (extent.top - extent.bottom)/size.height;\n  if (fitTo) { \n    if (fitTo.toLowerCase() === 'width') {\n      return xres;\n    } else if (fitTo.toLowerCase() === 'height') {\n      return yres;\n    } else {\n      throw new Error('\"fitTo\" option should be \"width\" or \"height\" ');\n    }\n  } else {\n    return Math.max(xres,yres);\n  }\n};\ng2svg.prototype.convert = function(geojson,options)  {\n  var opt = merge(this.options, options || {}, {clone: true});\n  var multiGeometries = ['MultiPoint','MultiLineString','MultiPolygon'];\n  var geometries = ['Point', 'LineString', 'Polygon'];\n  var svgElements = [];\n  if (geojson.type == 'FeatureCollection') {\n    for(var i=0; i< geojson.features.length; i++) {\n      svgElements = svgElements.concat(\n        this.convertFeature(geojson.features[i],opt));\n    }\n  } else if (geojson.type == 'Feature') {\n    svgElements = this.convertFeature(geojson,opt);\n  } else if (geojson.type == 'GeometryCollection') {\n    for(var i=0; i< geojson.geometries.length; i++) {\n      svgElements = svgElements.concat(\n        this.convertGeometry(geojson.geometries[i],opt));\n    }\n  } else if (converter[geojson.type]) {\n    svgElements = this.convertGeometry(geojson,opt);\n  } else {\n    return;\n  }\n  if(opt.callback) opt.callback.call(this,svgElements);\n  return svgElements;\n};\ng2svg.prototype.convertFeature = function(feature,options) {\n  if(!feature && !feature.geometry) return;\n  var opt = merge(this.options, options || {}, {clone: true});\n  opt.attributes = opt.attributes || {};\n  opt.attributes.id = opt.attributes.id || feature.id || \n    (feature.properties && feature.properties.id ? feature.properties.id : null);\n  if(feature.properties && feature.properties.data) {\n    for(var key in feature.properties.data) {\n      opt.attributes[key] = feature.properties.data[key]\n    }\n  }\n  return this.convertGeometry(feature.geometry,opt);\n};\ng2svg.prototype.convertGeometry = function(geom,options) {\n  if(converter[geom.type]) {\n    var opt = merge(this.options, options || {}, {clone: true});\n    var output = opt.output || 'svg';\n    var paths = converter[geom.type].call(this,geom,\n      this.res,\n      {x:this.mapExtent.left,y:this.mapExtent.top},\n      opt\n    );\n    var svgJsons,svgEles;\n    if (output.toLowerCase() == 'svg') {\n      svgJsons = paths.map(function(path) {\n        return pathToSvgJson(path,geom.type,opt.attributes,opt);\n      });\n      svgEles = svgJsons.map(function(json) {\n        return jsonToSvgElement(json,geom.type,opt);\n      });\n      return svgEles;\n    } else {\n      return paths;\n    }\n  } else {\n    return;\n  }\n};\nvar pathToSvgJson = function(path,type,attributes,opt) {\n  var svg = {};\n  var pointAsCircle = opt && opt.hasOwnProperty('pointAsCircle') \n    ? opt.pointAsCircle : false;\n  if((type == 'Point' || type == 'MultiPoint') && pointAsCircle) {\n    svg['cx'] = path.split(',')[0];\n    svg['cy'] = path.split(',')[1];\n    svg['r'] = opt && opt.r ? opt.r : '1';\n  } else {\n    svg = {d: path};\n    if(type == 'Polygon' || type == 'MultiPolygon') {\n      svg['fill-rule'] == 'evenodd'; \n    } \n  }\n  for (var key in attributes) {\n    svg[key]= attributes[key];\n  }\n  return svg;\n};\nvar jsonToSvgElement = function(json,type,opt) {\n  var pointAsCircle = opt && opt.hasOwnProperty('pointAsCircle') \n    ? opt.pointAsCircle : false;\n  var ele ='<path';\n  if((type == 'Point' || type == 'MultiPoint') && pointAsCircle) {\n    ele = '<circle';\n  }\n  for(var key in json) {\n    ele += ' ' + key +'=\"' + json[key] + '\"';\n  }\n  ele += '/>';\n  return ele;\n};\n\nmodule.exports = g2svg;\n",
    "var g2svg = require('./instance.js');\nvar geojson2svg = function(options) {\n  return new g2svg(options);\n};\n\nmodule.exports = geojson2svg;\n"
  ]
}